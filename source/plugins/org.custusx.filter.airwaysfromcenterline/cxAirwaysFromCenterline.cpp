

#include "cxAirwaysFromCenterline.h"
#include <vtkPolyData.h>
#include "cxBranchList.h"
#include "cxBranch.h"
#include "vtkCardinalSpline.h"
#include <vtkLine.h>
#include <vtkTubeFilter.h>
#include <vtkLineSource.h>
#include <vtkContourFilter.h>
#include <vtkPolyDataToImageStencil.h>
#include <cxImage.h>
#include "cxContourFilter.h"
#include <vtkImageData.h>
#include <vtkSphereSource.h>
#include <vtkDataSetSurfaceFilter.h>
#include <vtkPointData.h>
#include <vtkImageStencil.h>


namespace cx
{

AirwaysFromCenterline::AirwaysFromCenterline():
    mBranchListPtr(new BranchList)
{
}


AirwaysFromCenterline::~AirwaysFromCenterline()
{
}


Eigen::MatrixXd AirwaysFromCenterline::getCenterlinePositions(vtkPolyDataPtr centerline_r)
{

    int N = centerline_r->GetNumberOfPoints();
    Eigen::MatrixXd CLpoints(3,N);
    for(vtkIdType i = 0; i < N; i++)
        {
        double p[3];
        centerline_r->GetPoint(i,p);
        Eigen::Vector3d position;
		position(0) = p[0]; position(1) = p[1]; position(2) = p[2];
		CLpoints.block(0 , i , 3 , 1) = position;
		}
	return CLpoints;
}

void AirwaysFromCenterline::processCenterline(vtkPolyDataPtr centerline_r)
{
	if (mBranchListPtr)
		mBranchListPtr->deleteAllBranches();

    Eigen::MatrixXd CLpoints_r = getCenterlinePositions(centerline_r);

    mBranchListPtr->findBranchesInCenterline(CLpoints_r);

	mBranchListPtr->calculateOrientations();
	mBranchListPtr->smoothOrientations();
    mBranchListPtr->smoothBranchPositions(40);

	std::cout << "Number of branches in CT centerline: " << mBranchListPtr->getBranches().size() << std::endl;
}


/*
    AirwaysFromCenterline::generateTubes makes artificial airway tubes around the input centerline. The diameter
    of the tubes is decided by the generation number (trachea largest). There  is a lower boundary for the tube diameter
    making the peripheral airways larger than reality, which makes it possible to virtually navigate inside the tubes.
    The airways are generated by creating a volume with tubes around the centerlines and a sphere at each branching point,
    to make sure the tubes are fully connected. The output is a surface model generated from the image.
*/
vtkPolyDataPtr AirwaysFromCenterline::generateTubes()
{
    this->createEmptyImage();

    std::vector<BranchPtr> branches = mBranchListPtr->getBranches();


    //-----Generate tubes and spheres for each branch----------
    for (int i = 0; i < branches.size(); i++)
    {
        Eigen::MatrixXd positions = branches[i]->getPositions();
        vtkPointsPtr pointsPtr = vtkPointsPtr::New();
        vtkLineSourcePtr lineSourcePtr = vtkLineSourcePtr::New();
        int numberOfPositionsInBranch = positions.cols();
        pointsPtr->SetNumberOfPoints(numberOfPositionsInBranch);
        int displaceIndex = 0;

        if (branches[i]->getParentBranch()) // Add parents last position to get connected tubes
        {
            displaceIndex = 1;
            pointsPtr->SetNumberOfPoints(numberOfPositionsInBranch + 1);
            Eigen::MatrixXd parentPositions = branches[i]->getParentBranch()->getPositions();
            int numberOfPositionsParentBranch = parentPositions.cols();
            pointsPtr->SetPoint(0, parentPositions(0,numberOfPositionsParentBranch-1),
                                parentPositions(1,numberOfPositionsParentBranch-1),
                                parentPositions(2,numberOfPositionsParentBranch-1));
        }

        for (int j = 0; j < numberOfPositionsInBranch; j++)
            pointsPtr->SetPoint(j + displaceIndex, positions(0,j), positions(1,j), positions(2,j));

        lineSourcePtr->SetPoints(pointsPtr);

        // Create a tube (cylinder) around the line
        vtkTubeFilterPtr tubeFilterPtr = createTube(lineSourcePtr, branches[i]->findBranchRadius());
        addPolyDataToImage(tubeFilterPtr);

        //Add sphere at end of the branch
        double spherePosition[3];
        spherePosition[0] = positions(0,numberOfPositionsInBranch-1);
        spherePosition[1] = positions(1,numberOfPositionsInBranch-1);
        spherePosition[2] = positions(2,numberOfPositionsInBranch-1);
        vtkSphereSourcePtr spherePtr = createSphere(spherePosition, branches[i]->findBranchRadius());
        addPolyDataToImage(spherePtr);
    }

    //create contour from image
    vtkPolyDataPtr rawContour = ContourFilter::execute(
                mResultImagePtr,
            1, //treshold
            false, // reduce resolution
            true, // smoothing
            true, // keep topology
            0, // target decimation
            30, // number of iterations smoothing
            0.10 // band pass smoothing
    );

    return rawContour;
}

void AirwaysFromCenterline::createEmptyImage()
{
    std::vector<BranchPtr> branches = mBranchListPtr->getBranches();

    mResultImagePtr = vtkImageDataPtr::New();
    vtkPointsPtr pointsPtr = vtkPointsPtr::New();

    int numberOfPoints = 0;
    for (int i = 0; i < branches.size(); i++)
        numberOfPoints += branches[i]->getPositions().cols();

    pointsPtr->SetNumberOfPoints(numberOfPoints);

    int pointIndex = 0;
    for (int i = 0; i < branches.size(); i++)
    {
        Eigen::MatrixXd positions = branches[i]->getPositions();
        for (int j = 0; j < positions.cols(); j++)
        {
            pointsPtr->SetPoint(pointIndex, positions(0,j), positions(1,j), positions(2,j));
            pointIndex += 1;
        }
    }

    double bounds[6];
    pointsPtr->GetBounds(bounds);

    //Extend bounds to make room for surface model extended from centerline
    bounds[0] -= 10;
    bounds[1] += 10;
    bounds[2] -= 10;
    bounds[3] += 10;
    bounds[4] -= 10;
    bounds[5] -= 2; // to make top of trachea open

    mSpacing[0] = 0.5;  //Smaller spacing improves resolution but increases run-time
    mSpacing[1] = 0.5;
    mSpacing[2] = 0.5;
    mResultImagePtr->SetSpacing(mSpacing);

    // compute dimensions
    for (int i = 0; i < 3; i++)
        mDim[i] = static_cast<int>(std::ceil((bounds[i * 2 + 1] - bounds[i * 2]) / mSpacing[i]));


    mResultImagePtr->SetDimensions(mDim);
    mResultImagePtr->SetExtent(0, mDim[0] - 1, 0, mDim[1] - 1, 0, mDim[2] - 1);

    mOrigin[0] = bounds[0] + mSpacing[0] / 2;
    mOrigin[1] = bounds[2] + mSpacing[1] / 2;
    mOrigin[2] = bounds[4] + mSpacing[2] / 2;
    mResultImagePtr->SetOrigin(mOrigin);

    mResultImagePtr->AllocateScalars(VTK_UNSIGNED_CHAR,1);
}

void AirwaysFromCenterline::addPolyDataToImage(vtkPolyDataAlgorithmPtr mesh)
{
    vtkPolyDataToImageStencilPtr pol2stenc = vtkPolyDataToImageStencilPtr::New();
    pol2stenc->SetInputData(mesh->GetOutput());
    pol2stenc->SetOutputOrigin(mOrigin);
    pol2stenc->SetOutputSpacing(mSpacing);
    pol2stenc->SetOutputWholeExtent(mResultImagePtr->GetExtent());
    pol2stenc->Update();


    vtkImageStencilPtr imgstenc = vtkImageStencilPtr::New();
    imgstenc->SetInputData(mResultImagePtr);
    imgstenc->SetStencilData(pol2stenc->GetOutput());
    imgstenc->ReverseStencilOn();
    imgstenc->Update();

    mResultImagePtr = imgstenc->GetOutput();
}


vtkTubeFilterPtr AirwaysFromCenterline::createTube(vtkLineSourcePtr lineSourcePtr, double radius)
{
    vtkTubeFilterPtr tubeFilterPtr = vtkTubeFilterPtr::New();
    tubeFilterPtr->SetInputConnection(lineSourcePtr->GetOutputPort());
    tubeFilterPtr->SetRadius(radius); //default is .5
    tubeFilterPtr->SetNumberOfSides(50);
    tubeFilterPtr->Update();

    return tubeFilterPtr;
}

vtkSphereSourcePtr AirwaysFromCenterline::createSphere(double position[3], double radius)
{
    vtkSphereSourcePtr spherePtr = vtkSphereSourcePtr::New();
    spherePtr->SetCenter(position);
     spherePtr->SetRadius(1.05 * radius); // 5% larger radius to close holes
     spherePtr->SetThetaResolution(50);
     spherePtr->SetPhiResolution(50);
     spherePtr->Update();

    return spherePtr;
}


vtkPolyDataPtr AirwaysFromCenterline::getVTKPoints()
{
    vtkPolyDataPtr retval = vtkPolyDataPtr::New();
    vtkPointsPtr points = vtkPointsPtr::New();
    vtkCellArrayPtr lines = vtkCellArrayPtr::New();

    if (!mBranchListPtr)
            return retval;

    std::vector<BranchPtr> branches  = mBranchListPtr->getBranches();
    int pointIndex = 0;

    for (int i = 0; i < branches.size(); i++)
    {
        Eigen::MatrixXd positions = branches[i]->getPositions();
        int numberOfPositions = positions.cols();

        if (branches[i]->getParentBranch()) // Add parents last position to get connected centerlines
        {
            Eigen::MatrixXd parentPositions = branches[i]->getParentBranch()->getPositions();
            points->InsertNextPoint(parentPositions(0,parentPositions.cols()-1),parentPositions(1,parentPositions.cols()-1),parentPositions(2,parentPositions.cols()-1));
            pointIndex += 1;
        }

        for (int j = 0; j < numberOfPositions; j++)
        {
            points->InsertNextPoint(positions(0,j),positions(1,j),positions(2,j));

            if (j>1 || branches[i]->getParentBranch())
            {
                vtkIdType connection[2] = {pointIndex-1, pointIndex};
                lines->InsertNextCell(2, connection);
            }
            pointIndex += 1;
        }
    }

    retval->SetPoints(points);
    retval->SetLines(lines);
    return retval;
}


} /* namespace cx */
